/* ============================================
   챗봇 입력창 활성화/비활성화 관리
   ============================================ */

/**
 * 보고서 결과가 있는지 확인
 */
function hasReportResults() {
    const groqOutput = document.getElementById('groqOutput');
    const gptOutput = document.getElementById('gptOutput');
    const groqOutputCompare = document.getElementById('groqOutputCompare');
    const gptOutputCompare = document.getElementById('gptOutputCompare');
    
    const hasGroq = (groqOutput && groqOutput.textContent.trim()) || 
                    (groqOutputCompare && groqOutputCompare.textContent.trim());
    const hasGpt = (gptOutput && gptOutput.textContent.trim()) || 
                   (gptOutputCompare && gptOutputCompare.textContent.trim());
    
    return hasGroq || hasGpt;
}

/**
 * 챗봇 입력창 활성화/비활성화
 */
function updateChatbotInputState() {
    const chatInput = document.getElementById('chatbotInput');
    const sendBtn = document.getElementById('btnSendChat');
    const toggleGroq = document.getElementById('toggleGroq');
    const toggleGPT = document.getElementById('toggleGPT');
    
    if (!chatInput) return;
    
    const hasResults = hasReportResults();
    
    if (hasResults) {
        // 결과 있음: 활성화
        chatInput.disabled = false;
        chatInput.style.opacity = '1';
        chatInput.placeholder = '요청 내용을 입력하세요. (예: "상담 과정을 더 자세하게")';
        
        if (sendBtn) sendBtn.disabled = false;
        if (toggleGroq) toggleGroq.disabled = false;
        if (toggleGPT) toggleGPT.disabled = false;
    } else {
        // 결과 없음: 비활성화
        chatInput.disabled = true;
        chatInput.style.opacity = '0.5';
        chatInput.placeholder = '보고서를 먼저 생성해주세요';
        chatInput.value = '';
        
        if (sendBtn) sendBtn.disabled = true;
        if (toggleGroq) toggleGroq.disabled = true;
        if (toggleGPT) toggleGPT.disabled = true;
    }
}

/**
 * 챗봇 입력창 상태 감시 시작
 */
function startChatbotStateMonitoring() {
    // 초기 상태 설정
    updateChatbotInputState();
    
    // 출력 영역 변화 감시 (MutationObserver)
    const outputIds = ['groqOutput', 'gptOutput', 'groqOutputCompare', 'gptOutputCompare'];
    const observer = new MutationObserver(function() {
        updateChatbotInputState();
    });
    
    outputIds.forEach(function(id) {
        const elem = document.getElementById(id);
        if (elem) {
            observer.observe(elem, {
                childList: true,
                characterData: true,
                subtree: true
            });
        }
    });
    
    // 주기적으로도 체크 (fallback)
    setInterval(updateChatbotInputState, 2000);
}

// 페이지 로드 시 감시 시작
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function() {
        setTimeout(startChatbotStateMonitoring, 500);
    });
} else {
    setTimeout(startChatbotStateMonitoring, 500);
}

/* ============================================
   챗봇 사이드바 토글
   ============================================ */

function toggleChatbot() {
    const chatbotModal = document.getElementById('chatbotModal');
    const settingsSidebar = document.getElementById('settingsSidebar');
    const mainArea = document.querySelector('.main-area');
    const overlay = document.getElementById('chatbotOverlay');

    if (!chatbotModal) return;

    const isActive = chatbotModal.classList.contains('active');

    if (isActive) {
        chatbotModal.classList.remove('active');
        if (mainArea) mainArea.classList.remove('chatbot-open');
        if (overlay) overlay.classList.remove('active');
    } else {
        chatbotModal.classList.add('active');
        if (mainArea) mainArea.classList.add('chatbot-open');
        if (overlay) overlay.classList.add('active');

        if (settingsSidebar && settingsSidebar.classList.contains('open')) {
            settingsSidebar.classList.remove('open');
            if (mainArea) mainArea.classList.remove('sidebar-open');
        }

        updateChatbotInputState();

        const input = document.getElementById('chatbotInput');
        if (input && !input.disabled) {
            setTimeout(() => input.focus(), 33);
        }
    }
}

function closeChatbot() {
    const modal = document.getElementById('chatbotModal');
    const mainArea = document.querySelector('.main-area');
    const overlay = document.getElementById('chatbotOverlay');
    if (modal) modal.classList.remove('active');
    if (mainArea) mainArea.classList.remove('chatbot-open');
    if (overlay) overlay.classList.remove('active');
}

// 이벤트 리스너 등록
function initChatbotEvents() {
    // X 버튼 클릭
    const closeBtn = document.getElementById('chatbotCloseBtn');
    if (closeBtn) {
        closeBtn.addEventListener('click', closeChatbot);
    }
    
    // ESC 키로 닫기
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            const modal = document.getElementById('chatbotModal');
            if (modal && modal.classList.contains('active')) {
                closeChatbot();
            }
        }
    });
}

// 페이지 로드 시 이벤트 리스너 등록
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initChatbotEvents);
} else {
    initChatbotEvents();
}

/* ============================================
   메시지 전송 이벤트
   ============================================ */

// 메시지 전송 처리
function handleChatSend() {
    console.log('[Chatbot] handleChatSend 호출됨');
    
    const groqEnabled = document.getElementById('toggleGroq')?.checked;
    const gptEnabled = document.getElementById('toggleGPT')?.checked;
    const messageInput = document.getElementById('chatbotInput');
    const message = messageInput?.value.trim();
    
    // 검증1: 둘 다 OFF인 경우
    if (!groqEnabled && !gptEnabled) {
        console.log('[Chatbot] 모델 선택 안됨');
        showToast('응답 받을 곳을 선택해주세요', 2000);
        return;
    }
    
    // 검증2: 메시지 비어있는지 확인
    if (!message) {
        console.log('[Chatbot] 메시지 비어있음');
        showToast('요청 메시지를 입력해주세요', 2000);
        if (messageInput) messageInput.focus();
        return;
    }
    
    // 검증3: 보고서 결과 확인
    if (!hasReportResults()) {
        console.log('[Chatbot] 보고서 결과 없음');
        showToast('먼저 보고서를 먼저 생성해주세요', 2500);
        return;
    }
    
    console.log('[Chatbot] 검증 통과, 전송 시작');
    
    // 사용자 메시지 표시
    addChatMessage('user', message);
    
    // 입력창 초기화
    clearChatInput();
    
    // 로딩 상태 설정
    setLoadingState(true);
    
    // 전송 로직
    if (groqEnabled && gptEnabled) {
        // 둘 다 전송
        sendToBoth(message);
    } else if (groqEnabled) {
        // Groq만 전송
        sendToGroq(message);
    } else if (gptEnabled) {
        // GPT만 전송
        sendToGPT(message);
    }
}

// 전송 버튼 이벤트 등록
function initSendButtonEvent() {
    const sendBtn = document.getElementById('btnSendChat');
    console.log('[Chatbot] 전송 버튼 초기화:', sendBtn ? '찾음' : '못찾음');
    
    if (sendBtn) {
        // 기존 이벤트 제거 (중복 방지)
        sendBtn.removeEventListener('click', handleChatSend);
        sendBtn.addEventListener('click', handleChatSend);
        console.log('[Chatbot] 전송 버튼 이벤트 등록 완료');
    } else {
        console.error('[Chatbot] btnSendChat 요소를 찾을 수 없습니다!');
    }
}

// 페이지 로드 시 전송 버튼 이벤트 등록
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initSendButtonEvent);
} else {
    initSendButtonEvent();
}

/* ============================================
   메시지 추가 함수
   ============================================ */

// HTML 이스케이프 (XSS 방지)
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// 챗봇 메시지 추가
function addChatMessage(role, content, model = '') {
    const messagesContainer = document.getElementById('chatbotMessages');
    if (!messagesContainer) return;
    
    const messageDiv = document.createElement('div');
    messageDiv.className = `chat-message chat-message--${role}`;
    
    if (role === 'ai') {
        // AI 메시지: badge + content
        const badge = document.createElement('div');
        badge.className = 'message-badge';
        badge.textContent = model || 'AI';
        messageDiv.appendChild(badge);
        
        const contentDiv = document.createElement('div');
        contentDiv.className = 'message-content';
        contentDiv.innerHTML = content; // AI 응답은 HTML 포함 가능
        messageDiv.appendChild(contentDiv);
        
    } else if (role === 'user') {
        // 사용자 메시지: content + time
        const contentDiv = document.createElement('div');
        contentDiv.className = 'message-content';
        contentDiv.textContent = content; // 사용자 입력은 텍스트만
        messageDiv.appendChild(contentDiv);
        
        const timeDiv = document.createElement('div');
        timeDiv.className = 'message-time';
        const now = new Date();
        const hours = String(now.getHours()).padStart(2, '0');
        const minutes = String(now.getMinutes()).padStart(2, '0');
        timeDiv.textContent = `${hours}:${minutes}`;
        messageDiv.appendChild(timeDiv);
        
    } else if (role === 'system') {
        // 시스템 메시지: content만
        const contentDiv = document.createElement('div');
        contentDiv.className = 'message-content';
        contentDiv.innerHTML = content;
        messageDiv.appendChild(contentDiv);
    }
    
    // 메시지 추가
    messagesContainer.appendChild(messageDiv);
    
    // 자동 스크롤
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

/* ============================================
   Enter 키 처리
   ============================================ */

// Enter 키 처리 초기화
function initEnterKeyHandler() {
    const input = document.getElementById('chatbotInput');
    if (!input) return;
    
    input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            // Enter만 누르면 전송
            e.preventDefault();
            handleChatSend();
        }
        // Shift+Enter는 기본 동작 (줄바꿈)
    });
}

// 페이지 로드 시 Enter 핸들러 등록
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initEnterKeyHandler);
} else {
    initEnterKeyHandler();
}

/* ============================================
   입력창 초기화
   ============================================ */

function clearChatInput() {
    const input = document.getElementById('chatbotInput');
    if (input) {
        input.value = '';
        input.style.height = 'auto';
    }
}

/* ============================================
   로딩 상태 관리 - 명확한 "작성중..." 표시
   ============================================ */

let isAnimating = false; // 전역 변수로 애니메이션 상태 관리

function setLoadingState(isLoading) {
    const sendBtn = document.getElementById('btnSendChat');
    const chatInput = document.getElementById('chatbotInput');
    const groqToggle = document.getElementById('toggleGroq');
    const gptToggle = document.getElementById('toggleGPT');
    
    console.log('[Chatbot] 로딩 상태 변경:', isLoading);
    
    if (isLoading) {
        // 로딩 시작
        isAnimating = true;
        
        if (sendBtn) {
            sendBtn.disabled = true;
            sendBtn.classList.add('loading');
            
            // 버튼 텍스트를 "작성중..."으로 변경
            const sendText = sendBtn.querySelector('.send-text');
            if (sendText) {
                sendText.setAttribute('data-original-text', sendText.textContent);
                sendText.textContent = '작성중...';
            }
            
            // 스피너 추가 (중복 방지)
            const existingSpinner = sendBtn.querySelector('.spinner');
            if (!existingSpinner) {
                const spinner = document.createElement('span');
                spinner.className = 'spinner';
                spinner.style.cssText = 'display: inline-block; width: 12px; height: 12px; border: 2px solid #fff; border-top-color: transparent; border-radius: 50%; animation: spin 0.8s linear infinite; margin-right: 6px;';
                sendBtn.insertBefore(spinner, sendBtn.firstChild);
            }
        }
        
        if (chatInput) {
            chatInput.disabled = true;
            chatInput.style.opacity = '0.6';
            chatInput.placeholder = '수정 중입니다...';
        }
        
        if (groqToggle) groqToggle.disabled = true;
        if (gptToggle) gptToggle.disabled = true;
        
    } else {
        // 로딩 종료
        isAnimating = false;
        
        if (sendBtn) {
            sendBtn.disabled = false;
            sendBtn.classList.remove('loading');
            
            // 버튼 텍스트 복원
            const sendText = sendBtn.querySelector('.send-text');
            if (sendText) {
                const originalText = sendText.getAttribute('data-original-text') || '요청';
                sendText.textContent = originalText;
                sendText.removeAttribute('data-original-text');
            }
            
            // 스피너 제거
            const spinner = sendBtn.querySelector('.spinner');
            if (spinner) spinner.remove();
        }
        
        if (chatInput) {
            // 로딩 종료 후 상태는 updateChatbotInputState에서 관리
            updateChatbotInputState();
        }
        
        if (groqToggle) groqToggle.disabled = false;
        if (gptToggle) gptToggle.disabled = false;
    }
}

/* ============================================
   AI 호출 함수
   ============================================ */

// 프롬프트 생성
function buildChatPrompt(userMessage, currentReport) {
    return `당신은 상담보고서를 수정하는 AI 어시스턴트입니다.

[현재 보고서]
${currentReport}

[수정 지침]
1. 사용자의 요구사항을 정확히 반영하세요.
2. 수정하지 않는 부분은 원본 그대로 유지하세요.
3. 전문적이고 객관적인 어조를 유지하세요.
4. 수정된 전체 보고서를 반환하세요.
5. 어떤 설명이나 주석 없이 보고서 내용만 반환하세요.
6. 보고서 형식(섹션 구조)을 유지하세요.
7. **마크다운 형식으로 작성하세요**:
   - 섹션 제목: ## 제목
   - 하위 제목: ### 하위제목
   - 강조: **중요한 내용**
   - 목록: - 항목 또는 1. 순서

[사용자 요청]
${userMessage}

[수정된 보고서]`;
}

// 변경 하이라이트 (간단 구현)
function highlightModifiedText(originalText, modifiedText) {
    // 실제로는 diff 알고리즘을 사용하는 것이 좋지만, 여기서는 간단히 처리
    return modifiedText; // 전체를 반환 (하이라이트는 CSS에서 처리 가능)
}

// 타이핑 애니메이션
async function typeModifiedText(element, htmlContent) {
    if (typeof typeHtmlWithAnimation === 'function') {
        await typeHtmlWithAnimation(element, htmlContent);
    } else {
        // fallback: 즉시 표시
        element.innerHTML = htmlContent;
    }
}

// 결과 반영 (타이핑) - 비교 탭에도 애니메이션 적용, 마크다운 렌더링 포함
async function updateReportWithTyping(model, highlightedHtml, plainText) {
    const outputId = (model === 'groq') ? 'groqOutput' : 'gptOutput';
    const out = document.getElementById(outputId);
    
    if (!out) return;
    
    // 원본 텍스트 저장 (복사 기능을 위해)
    out.setAttribute('data-raw-text', plainText);
    
    // 글자수 먼저 업데이트
    const count = plainText.length;
    const countElem = document.getElementById(`${model}Count`);
    if (countElem) countElem.textContent = `${count}자`;
    
    const cmpCountElem = document.getElementById(`${model}CountCompare`);
    if (cmpCountElem) cmpCountElem.textContent = `${count}자`;
    
    // 복사 버튼 활성화
    const copyBtn = document.getElementById(`${model}CopyBtn`);
    if (copyBtn) copyBtn.disabled = false;
    
    const copyBtn2 = document.getElementById(`${model}CopyBtnCompare`);
    if (copyBtn2) copyBtn2.disabled = false;
    
    // 마크다운 렌더링 적용
    let finalHtml = highlightedHtml;
    if (typeof renderMarkdown === 'function') {
        finalHtml = renderMarkdown(plainText);
        out.classList.add('markdown-rendered');
    }
    
    // 현재 탭 확인
    const activeTab = document.querySelector('.output-tab.active');
    const activeTabName = activeTab ? activeTab.getAttribute('data-tab') : 'compare';
    
    if (activeTabName === 'compare') {
        // 비교 모드: 비교 탭에 애니메이션 적용
        const cmpId = (model === 'groq') ? 'groqOutputCompare' : 'gptOutputCompare';
        const cmp = document.getElementById(cmpId);
        if (cmp) {
            cmp.setAttribute('data-raw-text', plainText);
            cmp.style.display = 'block';
            if (typeof renderMarkdown === 'function') {
                cmp.classList.add('markdown-rendered');
            }
            await typeModifiedText(cmp, finalHtml);
        }
        // 개별 탭에는 즉시 반영 (애니메이션 없음)
        out.style.display = 'block';
        out.innerHTML = finalHtml;
    } else {
        // 개별 탭 모드: 해당 탭에 애니메이션 적용
        out.style.display = 'block';
        await typeModifiedText(out, finalHtml);
        // 비교 탭에는 즉시 반영 (애니메이션 없음)
        const cmpId = (model === 'groq') ? 'groqOutputCompare' : 'gptOutputCompare';
        const cmp = document.getElementById(cmpId);
        if (cmp) {
            cmp.setAttribute('data-raw-text', plainText);
            if (typeof renderMarkdown === 'function') {
                cmp.classList.add('markdown-rendered');
            }
            cmp.innerHTML = finalHtml;
        }
    }
}

// API 키 가져오기 (app.js의 함수 재사용)
function getGroqApiKey() {
    if (typeof loadApiKeySafely === 'function') {
        return loadApiKeySafely('groqApiKey');
    }
    return '';
}

function getGPTApiKey() {
    if (typeof loadApiKeySafely === 'function') {
        return loadApiKeySafely('gptApiKey');
    }
    return '';
}

// Groq 전송
async function sendToGroq(message) {
    addChatMessage('system', '⏳ Groq가 보고서를 수정하고 있습니다...', 'Groq');
    
    try {
        const apiKey = getGroqApiKey();
        if (!apiKey) {
            throw new Error('Groq API 키가 설정되지 않았습니다.');
        }
        
        // 현재 보고서 가져오기
        const groqOutput = document.getElementById('groqOutput');
        if (!groqOutput || !groqOutput.textContent.trim()) {
            throw new Error('Groq 보고서가 없습니다. 먼저 보고서를 생성해주세요.');
        }
        const currentReport = groqOutput.textContent;
        
        // 프롬프트 생성
        const prompt = buildChatPrompt(message, currentReport);
        
        // API 호출
        const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
            },
            body: JSON.stringify({
                model: 'llama-3.3-70b-versatile',
                messages: [
                    {
                        role: 'user',
                        content: prompt
                    }
                ],
                temperature: 0.7,
                max_tokens: 4000
            })
        });
        
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(`API 오류 (${response.status}): ${errorData.error?.message || response.statusText}`);
        }
        
        const data = await response.json();
        const updatedReport = data.choices[0].message.content;
        
        // 변경 하이라이트 적용
        const highlightedHtml = highlightModifiedText(currentReport, updatedReport);
        
        // 타이핑 애니메이션으로 결과 반영
        await updateReportWithTyping('groq', highlightedHtml, updatedReport);
        
        // 완료 메시지
        addChatMessage('ai', '✅ Groq가 보고서를 수정했습니다.', 'Groq');
        
    } catch (error) {
        console.error('Groq Error:', error);
        addChatMessage('system', `❌ Groq 오류: ${error.message}`, 'Groq');
    } finally {
        setLoadingState(false);
    }
}

// GPT 전송
async function sendToGPT(message) {
    addChatMessage('system', '⏳ GPT가 보고서를 수정하고 있습니다...', 'GPT');
    
    try {
        const apiKey = getGPTApiKey();
        if (!apiKey) {
            throw new Error('GPT API 키가 설정되지 않았습니다.');
        }
        
        // 현재 보고서 가져오기
        const gptOutput = document.getElementById('gptOutput');
        if (!gptOutput || !gptOutput.textContent.trim()) {
            throw new Error('GPT 보고서가 없습니다. 먼저 보고서를 생성해주세요.');
        }
        const currentReport = gptOutput.textContent;
        
        // 프롬프트 생성
        const prompt = buildChatPrompt(message, currentReport);
        
        // API 호출
        const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`,
                'HTTP-Referer': 'https://counseling-journal.app',
                'X-Title': 'Counseling Journal Tool'
            },
            body: JSON.stringify({
                model: 'openai/gpt-4o-mini',
                messages: [
                    {
                        role: 'user',
                        content: prompt
                    }
                ],
                temperature: 0.7,
                max_tokens: 4000
            })
        });
        
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(`API 오류 (${response.status}): ${errorData.error?.message || response.statusText}`);
        }
        
        const data = await response.json();
        const updatedReport = data.choices[0].message.content;
        
        // 변경 하이라이트 적용
        const highlightedHtml = highlightModifiedText(currentReport, updatedReport);
        
        // 타이핑 애니메이션으로 결과 반영
        await updateReportWithTyping('gpt', highlightedHtml, updatedReport);
        
        // 완료 메시지
        addChatMessage('ai', '✅ GPT가 보고서를 수정했습니다.', 'GPT');
        
    } catch (error) {
        console.error('GPT Error:', error);
        addChatMessage('system', `❌ GPT 오류: ${error.message}`, 'GPT');
    } finally {
        setLoadingState(false);
    }
}

// 동시 전송
async function sendToBoth(message) {
    addChatMessage('system', '⏳ Groq와 GPT가 동시에 수정 중...', 'Both');
    
    await Promise.all([
        sendToGroq(message),
        sendToGPT(message)
    ]);
    
    addChatMessage('system', '✅ 두 모델 모두 수정 완료!', 'Both');
}

// 스피너 애니메이션 CSS (동적 추가)
if (!document.getElementById('chatbot-spinner-style')) {
    const style = document.createElement('style');
    style.id = 'chatbot-spinner-style';
    style.textContent = `
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    `;
    document.head.appendChild(style);
}
